Title:       Explicit Type for Enumerations
Author:      James Cownie
Champion:    James Cownie
Submit-Date: 2004-06-18
Propid:      040618.1
Type:        Extension
Status:      Accepted with modifications
Version:     3

The problem
-----------

Consider a C++ code like this on a machine with a 32 bit int :-

  #include 
  #include 

  int fn (int )
  {
    printf ("fn (int)\n");
    fflush (stdout);
    return 1;
  }

  int fn (unsigned int )
  {
    printf ("fn (unsigned int)\n");
    fflush (stdout);
    return 2;
  }

  enum limits {
    mostpos = 0x7fffffff,
    mostneg = (1<<31)
  };

  enum limits2 {
    big    = 0x7fffffff,
    bigger = 0x80000000u
  };

  int main (int argc, char ** argv)
  {
    limits l;

    printf ("mostpos = %d, mostneg = %d, sizeof (limits) %d\n", mostpos,
         mostneg, sizeof(l));

    fn (mostpos);
    fn (bigger);

    return 0;
  }


Two different compilers generate virtually identical DWARF like this
for the enumerations limits and limits2.

 <1><52b>: Abbrev Number: 23 (`DW_TAG_enumeration_type`)
     `DW_AT_name`        : limits
     `DW_AT_byte_size`   : 4
 <2><53a>: Abbrev Number: 24 (`DW_TAG_enumerator`)
     `DW_AT_name`        : mostpos
     `DW_AT_const_value` : 2147483647
 <2><548>: Abbrev Number: 24 (`DW_TAG_enumerator`)
     `DW_AT_name`        : mostneg
     `DW_AT_const_value` : -2147483648

 <1><557>: Abbrev Number: 23 (`DW_TAG_enumeration_type`)
     `DW_AT_name`        : limits2
     `DW_AT_byte_size`   : 4
 <2><567>: Abbrev Number: 24 (`DW_TAG_enumerator`)
     `DW_AT_name`        : big
     `DW_AT_const_value` : 2147483647
 <2><571>: Abbrev Number: 24 (`DW_TAG_enumerator`)
     `DW_AT_name`        : bigger
     `DW_AT_const_value` : -2147483648

Observe that these enumeration types and enumerators are described
identically. There is no information here which allows the debugger to
determine that the underlying types of the enumerations differ.

This means that it is impossible for the debugger correctly
to evaluate the expressions "fn(mostpos)" or "fn(bigger)", since it
can't work out the underlying type of the enumeration types, and
therefore can't resolve the overloaded functions.
[proposal here, not using `DW_AT_type`, not shown.]


Chris Quenelle  responded.
Jim Blandy suggested `DW_AT_type`.
Michael Eager responded positively to  this notion.

PROPOSAL:

In section 5.7, Enumeration Type Entries, the following
paragraph be added:

"The `DW_TAG_enumeration_type` may have a `DW_AT_type`
attribute referring to the data type which implements
the type. "

Italics:
"If the `DW_AT_type` attribute refers to a
type with a `DW_AT_name` a debugger might choose to display
the type name in some way, depending on the source language."

=======================================

Accepted without italic text.
