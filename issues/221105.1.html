<html><head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>DWARF Issue</title>
</head><body>
<body>
<table style="text-align: left; width: 800px; height: 136px;" border="0">
  <tbody>
    <tr>
      <td
 style="vertical-align: middle; text-align: center; width: 153px;"><img
 src="dwarf.png" border="0"> </td>
      <td style="width: 372px;">
      <div style="text-align: center;"> </div>
      <h1 style="text-align: center;">DWARF Standard</h1>
      <div style="text-align: center;"> </div>
      </td>
    </tr>
  </tbody>
</table>
<table style="text-align: left; width: 800px; height: 26px;" border="0"
 cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <td style="width: 168px; background-color: rgb(51, 51, 255);"><br>
      </td>
      <td
 style="text-align: center; background-color: rgb(51, 51, 255);"><a
 style="color: rgb(255, 255, 255);"
 href="/">HOME</a><br>
      </td>
      <td
 style="text-align: center; background-color: rgb(51, 51, 255);"><a
 style="color: rgb(255, 255, 255);"
 href="/Download.html">SPECIFICATIONS</a><br>
      </td>
      <td
 style="text-align: center; background-color: rgb(51, 51, 255);"><a
 style="color: rgb(255, 255, 255);"
 href="http://wiki.dwarfstd.dev/index.php?title=DWARF_FAQ">FAQ</a><br>
      </td>
      <td
 style="text-align: center; background-color: rgb(51, 51, 255);"><a
 style="color: rgb(255, 255, 255);"
 href="/issues.html">ISSUES</a><br>
      </td>
      <td style="width: 168px; background-color: rgb(51, 51, 255);"><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>

<table style="text-align: left; width: 794px; height: 25px;" border="1" cellpadding="2" cellspacing="2">
  <tbody>

    <tr>
      <td>221105.1</td>
      <td>Kyle Huey</td>
      <td>Add a mechanism for specifying subprogram return value locations</td>
      <td>Enhancement</td>
      <td>Open</td>
      <td>Caroline Tice</td>
    </tr>
  </tbody>
</table>
<pre><big>

Section 3.3.2, pg 78

DWARF allows a DW_TAG_subprogram/DW_TAG_inlined_subroutine (the latter 
via DW_AT_abstract_origin) to note their return type with a DW_AT_type, 
as detailed in Section 3.3.2. It does not, however, provide any 
information about where the return type is in the program at the 
subprogram boundary. Debuggers that support printing return values 
at function exit (e.g. gdb) currently infer this from the platform ABI 
(e.g. `amd64_return_value` in gdb/amd64-tdep.c). There is no requirement 
that arbitrary functions actually follow the platform's standard ABI 
though, and when this inference fails, it fails silently, presenting 
the wrong value to users.

There are, in my opinion, two interesting cases:

1) Cases where the function follows some sort of ABI, just not the 
platform's standard ABI.

The Rust compiler, for instance, doesn't always follow the standard 
SYSV AMD64 ABI when compiling for that platform. 
See https://github.com/rust-lang/rust/issues/85641 for one real world 
example that silently breaks gdb.

In theory this case could be covered by adding a DW_CC_rust value for 
the DW_AT_calling_convention attribute to the spec, and downstream 
tools could be taught what that means and how to process it accordingly. 
I think this is more complicated than having the compiler directly emit 
the location information, and it wouldn't cover the second case.

2) Inline functions.

Inline functions don't necessarily follow any ABI. Depending on the 
optimizations performed after inlining, they may not even have proper 
bounds to determine what constitutes a single invocation of the function 
(imagine an inline function whose instructions have been intermingled 
by the optimizer with the instructions of its containing function). 
But there are common cases where a inlined function does have a 
meaningful and easy-to-determine return value.

Consider the simple C++ program

#include &lt;iostream&gt;

using namespace std;

inline bool greater_than(int x, int y) {
    return x &gt; y;
}

int main(int argc) {
    if (greater_than(argc, 4)) {
        cout &lt;&lt; &quot;I have more than 3 arguments\n&quot;;
    } else {
        cout &lt;&lt; &quot;I have 3 or fewer arguments\n&quot;;
    }
    return 0;
}

An optimizing compiler (e.g. gcc 12.2 with -O2) can convert the 
greater_than function into a single comparison instruction inlined 
into main. The corresponding bit in the flags register is clearly 
not the ABI-specified location for the return value.


I propose to add language to the spec allowing DW_AT_location to be 
present on DW_TAG_subprogram/DW_TAG_inlined_subroutine. When present, 
it would contain a location expression specifying the location of the 
function's return value. (In the two examples above, on x86-64, the 
expressions &quot;DW_OP_reg0 DW_OP_piece 4 DW_OP_reg1 DW_OP_piece 4&quot; and 
&quot;DW_OP_regx 49 DW_OP_dup DW_OP_const1u 64 DW_OP_and DW_OP_lit6 
DW_OP_shr DW_OP_lit0 DW_OP_eq DW_OP_swap DW_OP_dup DW_OP_const1u 128 
DW_OP_and DW_OP_lit7 DW_OP_shr DW_OP_swap DW_OP_lit1 DW_OP_and 
DW_OP_eq DW_OP_eq&quot; respectively are capable of encoding the return 
values). If it's not present, debuggers and other tools can fall back 
to their current behavior.

</big></pre>
<br><br>

<table style="text-align: left; width: 800px;" border="0" cellpadding="0" cellspacing="0">
  <small>
  </small><tbody><small>
    </small><tr><small>
      </small><td style="width: 800px; text-align: center;"><small>
      <font class="footmsg">
All logos and trademarks in this site are property of their respective
owner. <br>
The comments are property of their posters, all the rest &copy; 2007-2022
by DWARF Standards Committee.</font></small></td><small>
    </small></tr><small>
  </small></tbody><small>
  </small>
</table>

</body></html>
